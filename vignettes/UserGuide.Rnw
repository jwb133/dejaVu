\documentclass{article}

\usepackage{fullpage}
\usepackage{url}
\usepackage{color}
\usepackage{authblk}
\usepackage{amsmath}
\usepackage{amssymb}

%\VignetteEngine{knitr::knitr}
%\VignetteIndexEntry{User Guide}

\begin{document}

\title{DejaVu User Guide}
\author[**]{Nikolas S. Burkoff}
\author[*]{David Ruau}

\affil[*]{AstraZeneca, B\&I, Advanced Analytics Centre, UK}
\affil[**]{Tessella, 26 The Quadrant, Abingdon Science Park, Abingdon, OX14 3YS, UK}


\renewcommand\Authands{ and }

\maketitle

\section{Introduction}

\section{Running a Single MI Example}

In this section we walk through a single MI example:
\begin{itemize}
\item Simulating Complete Data
\item Simulating Subject Dropout
\item Generating MI data sets
\item Analysing results using Rubin's formula 
\end{itemize}

See later in the guide for details of running a large number of examples and combining the results to estimate summary statistics such as power and Type I error.

In order to use the functionality of the package, it must be loaded:
<<load,message=FALSE>>=
library(dejaVu)
@

For reproducibility we set the random seed:
<<seed>>=
set.seed(1298711)
@

\subsection{Simulating Complete Data}

The \texttt{SimulateComplete} function is used to generate a complete data set of subject outcomes for a recurrent event study with follow up time $T$ and the number of events for each subject, $n_i$ is given by a negative binomial process. 

Under the negative binomial assumption the time interval between adjacent event for a given subject are exponentially distributed with rate $\lambda_i/T$ where $\lambda_i \sim \mathrm{Gamma}(1/k,k\mu)$ and $k$ is the dispersion parameter and $\mu$ the mean number of events ($k$ and $\mu$ can be different for each treatment group)

Specifically
\begin{equation}
\label{nbpdf}
\mathbb{P}(n_i=r) = \left.\frac{\Gamma(\gamma+ r)}{\Gamma(r+1)\Gamma(\gamma)}p^r(1-p)^{\gamma}\right.\end{equation} where $\gamma=1/k$ and $p=\frac{k\mu}{1+k\mu}$.


The \texttt{SimulateComplete} function takes the following arguments:
\begin{itemize}
\item \texttt{study.time} $=T$
\item \texttt{number.subjects}: the number of subjects in each arm to simulate - if it is a single number then this will be used for both arms, otherwise a vector \texttt{c(number.control,number.active)}
\item \texttt{event.rates} $=\mu/T$: the event rates for each arm
\item \texttt{dispersions} $=k$, again either a single number if $k$ is the same for both arms otherwise a vector.
\end{itemize}

An example of the data generation procedure:
<<complete>>=
complete <- SimulateComplete(study.time=365, 
                      number.subjects=50, 
                      event.rates=c(0.01,0.005),
                      dispersions=0.25) 
print(complete)
summary(complete)
@

We can also access the data directly:
<<>>=
head(complete$data)
@

The SimulateComplete function returns a \texttt{SingleSim} object. See \texttt{help(SingleSim)} for further details.

\subsection{Subject Dropout}

Given a \texttt{SingleSim} object, we can use the \texttt{SimulateDropout} function to apply a dropout mechanism to create a data set which includes subject dropout. In this example we use a simple MCAR example. 

The \texttt{ConstantRateDrop} mechanism will give subjects exponentially distributed drop out times with subject specific rate $R$ where $\log(R) =$ \texttt{rate} $+ \mathcal{N}(0,$\texttt{var}$)$ 
<<CRdrop>>=
ConstantRateDrop(rate=0.0025,var=1)
@

This dropout mechanism can be used to create a data set with subject dropouts.
<<drop>>=
with.MCAR.dropout <- SimulateDropout(complete,
                    drop.mechanism=ConstantRateDrop(rate=0.0025,
                                                    var=1)) #var by default=0

@

Note the \texttt{censored.time} and \texttt{observed.events} have been updated:
<<dropsummary>>=
summary(with.MCAR.dropout)

head(with.MCAR.dropout$data)
@

See later in the tutorial for other available dropout mechanisms and a description of how to implement your own.   

\subsection{Generating MI data sets}

Given a \texttt{SingleSim} object we can fit a negative binomial model using the \texttt{Simfit} function. \textbf{Note a warning will be displayed if the model fit does not converge}. 
<<fit>>=
my.fit <- Simfit(with.MCAR.dropout,equal.dispersion=TRUE)
@

This creates a \texttt{SingleSimFit} object:
<<>>=
class(my.fit)

summary(my.fit)
@

We can output $\gamma$ and $p$ for the model fit (see Equation \eqref{nbpdf}):
<<ip>>=
my.fit$impute.parameters$gamma
my.fit$impute.parameters$p
@

Given a \texttt{SingleSimFit} object we can generate a set of imputed data sets:
<<imp>>=
imputed.data.sets <- Impute(fit = my.fit,
                            impute.mechanism = weighted_j2r(trt.weight=0),
                            N=10)
@

The \texttt{Impute} function requires three arguments, the fit, an impute mechanism and $N$ the number of data sets to impute.
We are using the weighted j2r impute mechanism with treatment weight=0 which implies missing counts for subjects in both arms will be imputed according to the mean of the control arm conditioned on the number of subject's observed events. 

TODO description of the method

See later in the tutorial for other available impute mechanisms and a description of how to implement your own.   

\subsection{Fitting MI datasets}

It is possible to access the individual imputed data sets:
<<>>=
sixth.data.set <- GetImputedDataSet(imputed.data.sets,index=6)

summary(sixth.data.set)

head(sixth.data.set$data)
@

Note the \texttt{actual.censored.time} column is the time the subject was actually censored at whereas the \texttt{censored.time} column is the time the subject was censored after applying the imputation. Similarly 

We can even fit a model to them. By default the \texttt{Simfit} function fits a negative binomial model, however, by using the family argument
a Poission or quasi-Poisson model can be fit instead.
<<>>=
sixth.fit <- Simfit(sixth.data.set,
                    family="poisson") 
                  
summary(sixth.fit)
@

It is possible to fit the entire set of imputed data sets in one go, again using the \texttt{Simfit} function:
<<>>=
fitted <- Simfit(imputed.data.sets,family="negbin")
@

We can create a data frame collating the fitted values:
<<>>=
head(as.data.frame(fitted))
@

We can also summarise the results -- the values shown here are calculated using Rubin's formula. (ADD ref or description here)
<<>>=
summary(fitted)
@

\section{Running Complete Scenarios}

In order to calculate the summary statistics such as power it is necessary to repeat the procedure multiple times. In this example we show how to easily replicate and combine the results

First we create a function which outputs a list of the summaries of the fits we are interested in:
<<scenario>>=
example.scenario <- function(){ 

  #simulate a complete data set
  sim <- SimulateComplete(study.time=365,number.subjects=100,
                       event.rates=c(0.01,0.005),dispersions=0.25)

  #take the simulated data set and apply an MCAR dropout mechanism...                         
  sim.with.MCAR.dropout <- SimulateDropout(sim,
                    drop.mechanism=ConstantRateDrop(rate=0.0025)) 

  #fit a Negative Binomial model 
  with.MCAR.fit <- Simfit(sim.with.MCAR.dropout,equal.dispersion=TRUE)

  #we can impute a set of 10 sets following the j2r mechanism using the fit
  impute.data.sets <- Impute(with.MCAR.fit,impute.mechanism = weighted_j2r(trt.weight=0),N=10)

  #we can then fit models to the entire imputed data set
  fit.imputed.set <- Simfit(impute.data.sets)

  #output the summary values
  return(list(MI=summary(fit.imputed.set), #for MI
              dropout=summary(with.MCAR.fit), #for dropout
              complete=summary(Simfit(sim)))) #for complete data set
}
@

Next we run the simulation a large number of times:
<<rep>>=
answer <- replicate(500,example.scenario(),simplify = FALSE)
@

and process the results using the \texttt{extract_results} function: 
<<extract>>=
MI.answer <- extract_results(answer,name="MI",description="Using j2r multiple imputation")
dropout.answer <- extract_results(answer,name="dropout",description="Using no imputation")
complete.answer <- extract_results(answer,name="complete",description="Using complete data sets")

class(MI.answer)
@

We can output a summary of the simulations as a data frame and summarize the results:
<<scenario.df>>=
head(as.data.frame(complete.answer))

summary(dropout.answer)

summary(MI.answer,use.adjusted.pval=TRUE)
@




\section{Additional Information}

\end{document}