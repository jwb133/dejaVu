\documentclass{article}

\usepackage{fullpage}
\usepackage{url}
\usepackage{color}
\usepackage{authblk}
\usepackage{amsmath}
\usepackage{amssymb}

%\VignetteEngine{knitr::knitr}
%\VignetteIndexEntry{User Guide}

\begin{document}

\title{DejaVu User Guide}
\author[**]{Nikolas S. Burkoff}
\author[*]{David Ruau}

\affil[*]{AstraZeneca, B\&I, Advanced Analytics Centre, UK}
\affil[**]{Tessella, 26 The Quadrant, Abingdon Science Park, Abingdon, OX14 3YS, UK}


\renewcommand\Authands{ and }

\maketitle

\section{Introduction}

\section{Running a Single MI Example}

In this section we walk through a single MI example:
\begin{itemize}
\item Simulating Complete Data
\item Simulating Subject Dropout
\item Generating MI data sets
\item Analysing results using Rubin's formula 
\end{itemize}

See later in the guide for details of running a large number of examples and combining the results to estimate summary statistics such as power and Type I error.

In order to use the functionality of the package, it must be loaded:
<<load,message=FALSE>>=
library(dejaVu)
@

For reproducibility we set the random seed:
<<seed>>=
set.seed(1298711)
@

\subsection{Simulating Complete Data}

The \texttt{SimulateComplete} function is used to generate a complete data set of subject outcomes for a recurrent event study with follow up time $T$ and the number of events for each subject, $n_i$ is given by a negative binomial process. 

Under the negative binomial assumption the time interval between adjacent event for a given subject are exponentially distributed with rate $\lambda_i/T$ where $\lambda_i \sim \mathrm{Gamma}(1/k,k\mu)$ and $k$ is the dispersion parameter and $\mu$ the mean number of events ($k$ and $\mu$ can be different for each treatment group)

Specifically
\begin{equation}
\label{nbpdf}
\mathbb{P}(n_i=r) = \left.\frac{\Gamma(\gamma+ r)}{\Gamma(r+1)\Gamma(\gamma)}p^r(1-p)^{\gamma}\right.\end{equation} where $\gamma=1/k$ and $p=\frac{k\mu}{1+k\mu}$.


The \texttt{SimulateComplete} function takes the following arguments:
\begin{itemize}
\item \texttt{study.time} $=T$
\item \texttt{number.subjects}: the number of subjects in each arm to simulate - if it is a single number then this will be used for both arms, otherwise a vector \texttt{c(number.control,number.active)}
\item \texttt{event.rates} $=\mu/T$: the event rates for each arm
\item \texttt{dispersions} $=k$, again either a single number if $k$ is the same for both arms otherwise a vector.
\end{itemize}

An example of the data generation procedure:
<<complete>>=
complete <- SimulateComplete(study.time=365, 
                      number.subjects=50, 
                      event.rates=c(0.01,0.005),
                      dispersions=0.25) 
print(complete)
summary(complete)
@

We can also access the data directly:
<<>>=
head(complete$data)
@

The SimulateComplete function returns a \texttt{SingleSim} object. See \texttt{help(SingleSim)} for further details.

\subsection{Subject Dropout}

Given a \texttt{SingleSim} object, we can use the \texttt{SimulateDropout} function to apply a dropout mechanism to create a data set which includes subject dropout. In this example we use a simple MCAR example. 

The \texttt{ConstantRateDrop} mechanism will give subjects exponentially distributed drop out times with subject specific rate $R$ where $\log(R) =$ \texttt{rate} $+ \mathcal{N}(0,$\texttt{var}$)$ 
<<CRdrop>>=
ConstantRateDrop(rate=0.0025,var=1)
@

This dropout mechanism can be used to create a data set with subject dropouts.
<<drop>>=
with.MCAR.dropout <- SimulateDropout(complete,
                    drop.mechanism=ConstantRateDrop(rate=0.0025,
                                                    var=1)) #var by default=0

@

Note the \texttt{censored.time} and \texttt{observed.events} have been updated:
<<dropsummary>>=
summary(with.MCAR.dropout)

head(with.MCAR.dropout$data)
@

See later in the tutorial for other available dropout mechanisms and a description of how to implement your own.   

\subsection{Generating MI data sets}

Given a \texttt{SingleSim} object we can fit a negative binomial model using the \texttt{Simfit} function. \textbf{Note a warning will be displayed if the model fit does not converge}. 
<<fit>>=
my.fit <- Simfit(with.MCAR.dropout,equal.dispersion=TRUE)
@

This creates a \texttt{SingleSimFit} object:
<<>>=
class(my.fit)

summary(my.fit)
@

We can output $\gamma$ and $p$ for the model fit (see Equation \eqref{nbpdf}):
<<ip>>=
my.fit$impute.parameters$gamma
my.fit$impute.parameters$p
@

Given a \texttt{SingleSimFit} object we can generate a set of imputed data sets:
<<imp>>=
imputed.data.sets <- Impute(fit = my.fit,
                            impute.mechanism = weighted_j2r(trt.weight=0),
                            N=10)
@

The \texttt{Impute} function requires three arguments, the fit, an impute mechanism and $N$ the number of data sets to impute.
We are using the weighted j2r impute mechanism with treatment weight=0 which implies missing counts for subjects in both arms will be imputed according to the mean of the control arm conditioned on the number of subject's observed events. 

TODO description of the method

See later in the tutorial for other available impute mechanisms and a description of how to implement your own.   

\subsection{Fitting MI datasets}

It is possible to access the individual imputed data sets:
<<>>=
sixth.data.set <- GetImputedDataSet(imputed.data.sets,index=6)

summary(sixth.data.set)

head(sixth.data.set$data)
@

Note the \texttt{actual.censored.time} column is the time the subject was actually censored at whereas the \texttt{censored.time} column is the time the subject was censored after applying the imputation. Similarly 

We can even fit a model to them. By default the \texttt{Simfit} function fits a negative binomial model, however, by using the family argument
a Poission or quasi-Poisson model can be fit instead.
<<>>=
sixth.fit <- Simfit(sixth.data.set,
                    family="poisson") 
                  
summary(sixth.fit)
@

It is possible to fit the entire set of imputed data sets in one go, again using the \texttt{Simfit} function:
<<>>=
fitted <- Simfit(imputed.data.sets,family="negbin")
@

We can create a data frame collating the fitted values:
<<>>=
head(as.data.frame(fitted))
@

We can also summarise the results -- the values shown here are calculated using Rubin's formula. (ADD ref or description here)
<<>>=
summary(fitted)
@

\section{Running Complete Scenarios}

In order to calculate the summary statistics such as power it is necessary to repeat the procedure multiple times. In this example we show how to easily replicate and combine the results

First we create a function which outputs a list of the summaries of the fits we are interested in:
<<scenario>>=
example.scenario <- function(){ 

  #simulate a complete data set
  sim <- SimulateComplete(study.time=365,number.subjects=100,
                       event.rates=c(0.01,0.005),dispersions=0.25)

  #take the simulated data set and apply an MCAR dropout mechanism...                         
  sim.with.MCAR.dropout <- SimulateDropout(sim,
                    drop.mechanism=ConstantRateDrop(rate=0.0025)) 

  #fit a Negative Binomial model 
  with.MCAR.fit <- Simfit(sim.with.MCAR.dropout,equal.dispersion=TRUE)

  #we can impute a set of 10 sets following the j2r mechanism using the fit
  impute.data.sets <- Impute(with.MCAR.fit,impute.mechanism = weighted_j2r(trt.weight=0),N=10)

  #we can then fit models to the entire imputed data set
  fit.imputed.set <- Simfit(impute.data.sets)

  #output the summary values
  return(list(MI=summary(fit.imputed.set), #for MI
              dropout=summary(with.MCAR.fit), #for dropout
              complete=summary(Simfit(sim)))) #for complete data set
}
@

Next we run the simulation a large number of times:
<<rep>>=
answer <- replicate(10,example.scenario(),simplify = FALSE)
@

and process the results using the \texttt{extract\_results} function: 
<<extract>>=
MI.answer <- extract_results(answer,name="MI",
                            description="Using j2r multiple imputation")
dropout.answer <- extract_results(answer,name="dropout",
                            description="Using no imputation")
complete.answer <- extract_results(answer,name="complete",
                            description="Using complete data sets")

class(MI.answer)
@

We can output a summary of the simulations as a data frame and summarize the results:
<<scenario.df>>=
head(as.data.frame(complete.answer))

summary(dropout.answer)

summary(MI.answer,use.adjusted.pval=TRUE)
@

\section{Additional Information}

\subsection{Additional Dropout mechanisms}

Alongside the \texttt{ConstantRateDrop} function. Additional dropout mechanisms have been implemented:

The \texttt{LinearRateChangeDrop} function allows a piecewise exponential drop out function where after $j$ events subjects have drop out rate $R_j$ where $R_j = C_j\exp(X_j)$ where $X_j \sim \mathcal{N}(0,\sigma^2)$ and $C_j = C+jD$ for constants $C$ and $D$.
<<linear>>=
drop.mec <- LinearRateChangeDrop(starting.rate=0.0025, #C in text above
                                 rate.change=0.0005, #D in text above
                                 var=1) #sigma^2 in text above by default var=0

drop.mec

with.MAR.dropout <- SimulateDropout(complete,
                    drop.mechanism=drop.mec)


@

Please let me know of any more you would like!

\paragraph{Implementing new drop out mechanisms (advanced!)}

It is possible to implement your own drop out mechanisms using the \texttt{CreateNewDropoutMechanism} function. A \texttt{DropoutMechanism} object should be created which contains 5 elements. We show a toy example here and see \texttt{help(DropoutMechanism.object)} and \texttt{help(CreateNewDropoutMechanism)} for further details.

In our toy\footnote{this is clearly not a sensible dropout method but shows how to implement dropout mechanisms} example we would like the dropout time to be $0.5T$ if subjects have exactly $W$ events and are on the control arm and $T$ (i.e. no dropouts) for all other subjects  where $W$ is a parameter chosen by the user. 

<<newdropout>>=

#we create a function which returns the new dropout mechanism
my.example.dropout <- function(W){ #W is the user parameter
  
  #First we create a function which must take in two arguments,
  #event.times - a list of a single subject's event times
  #data - a row of the data frame containing the subject details
  #and outputs the time of subject dropout 
  GetDropTime <- function(event.times,data){
    if(data$observed.events==W && data$arm==0){
      return(data$censored.time/2)
    }
    return(data$censored.time)
    
  }
  
  #we create a list of the columns from the data frame that
  #are used in the GetDropTime function
  cols.needed <- c("censored.time","arm","observed.events")
  
  #we call the CreateNewDropoutMechanism function
  #with the following arguments
  CreateNewDropoutMechanism(type="MNAR", #technically this is MNAR dropout
                            text="Toy example dropout", #the text to be output
                            cols.needed=cols.needed, #see above
                            GetDropTime=GetDropTime, #see above
                            parameters=list(the.value.of.W=W) #The parameters to be output
                            )

}

#we can view the dropout mechanism
my.example.dropout(6)

#we can use it
with.my.dropout <- SimulateDropout(complete,
                    drop.mechanism=my.example.dropout(6))

head(with.my.dropout$data)
@

\subsection{Additional Imputing Mechanisms}

By altering the \texttt{trt.weight} argument, the \texttt{weighted\_j2r} imputing mechanism can be used to generate different iomputing mechanisms:

If \texttt{trt.weight = 0} then imputation using this mechanism will follow the jump to reference (j2r) model whereby missing counts for subjects in both arms will be imputed according to the mean of the placebo arm conditioned on the subject's observed number of events

If \texttt{trt.weight = 1} then imputation using this mechanism will follow the MAR model whereby missing counts for subjects in each arm will be imputed according to the event rate of subjects in its treatment group conditioned on the subject's observed number of events

Finally if \texttt{trt.weight = 1} an additional argument \texttt{delta} can be included. It should be a vector of length 2, \texttt{c(control.delta,treatment.delta)} and in this case the mean number of expected events for the imputed missing data is multipled by the appropriate delta:
<<moreimp>>=
  weighted_j2r(trt.weight=1,delta=c(1,1.4))
@


\paragraph{Implementing new imputing mechanisms (advanced!)}

It is possible to implement your own imputing mechanisms using the \texttt{CreateNewImputeMechanism} function. A \texttt{ImputeMechanism} object should be created which contains 4 elements. We show a toy example here and see \texttt{help(ImputeMechanism.object)} and \texttt{help(CreateNewImputeMechanism)} for further details.

In our toy\footnote{this is clearly not a sensible imputing method but shows how to implement imputing mechanisms} example we would like

\end{document}